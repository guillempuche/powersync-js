"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[1111],{7038:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>r,contentTitle:()=>d,default:()=>o,frontMatter:()=>a,metadata:()=>i,toc:()=>l});var s=t(5893),c=t(1151);const a={id:"index",title:"@journeyapps/powersync-attachments",sidebar_label:"Readme",sidebar_position:0,custom_edit_url:null},d="@journeyapps/powersync-attachments",i={id:"attachments-sdk/index",title:"@journeyapps/powersync-attachments",description:"A PowerSync library to manage attachments in TypeScript and React Native apps.",source:"@site/docs/attachments-sdk/index.md",sourceDirName:"attachments-sdk",slug:"/attachments-sdk/",permalink:"/powersync-react-native-sdk/attachments-sdk/",draft:!1,unlisted:!1,editUrl:null,tags:[],version:"current",sidebarPosition:0,frontMatter:{id:"index",title:"@journeyapps/powersync-attachments",sidebar_label:"Readme",sidebar_position:0,custom_edit_url:null},sidebar:"docsSidebar",previous:{title:"Exports",permalink:"/powersync-react-native-sdk/react-sdk/modules"},next:{title:"Exports",permalink:"/powersync-react-native-sdk/attachments-sdk/modules"}},r={},l=[{value:"Installation",id:"installation",level:2},{value:"Usage",id:"usage",level:2},{value:"Example",id:"example",level:3},{value:"Steps to implement",id:"steps-to-implement",level:3},{value:"Attachment State",id:"attachment-state",level:2},{value:"Initial sync",id:"initial-sync",level:2},{value:"Syncing attachments",id:"syncing-attachments",level:2},{value:"Uploading",id:"uploading",level:3},{value:"Downloading",id:"downloading",level:3},{value:"Deleting attachments",id:"deleting-attachments",level:3},{value:"Expire Cache",id:"expire-cache",level:3}];function h(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,c.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h1,{id:"journeyappspowersync-attachments",children:"@journeyapps/powersync-attachments"}),"\n",(0,s.jsxs)(n.p,{children:["A ",(0,s.jsx)(n.a,{href:"https://powersync.co",children:"PowerSync"})," library to manage attachments in TypeScript and React Native apps."]}),"\n",(0,s.jsx)(n.p,{children:"Note: This package is currently in a beta release."}),"\n",(0,s.jsx)(n.h2,{id:"installation",children:"Installation"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"yarn"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"yarn add @journeyapps/powersync-attachments\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"npm"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"npm install @journeyapps/powersync-attachments\n"})}),"\n",(0,s.jsx)(n.h2,{id:"usage",children:"Usage"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"AttachmentQueue"})," class is used to manage and sync attachments in your app."]}),"\n",(0,s.jsx)(n.h3,{id:"example",children:"Example"}),"\n",(0,s.jsx)(n.p,{children:"In this example, the user captures photos when checklist items are completed as part of an inspection workflow."}),"\n",(0,s.jsxs)(n.p,{children:["The schema for the ",(0,s.jsx)(n.code,{children:"checklist"})," table:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const AppSchema = new Schema([\n  new Table({\n    name: 'checklists',\n    columns: [\n      new Column({ name: 'photo_id', type: ColumnType.TEXT }),\n      new Column({ name: 'description', type: ColumnType.TEXT }),\n      new Column({ name: 'completed', type: ColumnType.INTEGER }),\n      new Column({ name: 'completed_at', type: ColumnType.TEXT }),\n      new Column({ name: 'completed_by', type: ColumnType.TEXT })\n    ],\n    indexes: [\n      new Index({\n        name: 'inspections',\n        columns: [new IndexedColumn({ name: 'checklist_id' })]\n      })\n    ]\n  })\n]);\n"})}),"\n",(0,s.jsx)(n.h3,{id:"steps-to-implement",children:"Steps to implement"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["Create a new class ",(0,s.jsx)(n.code,{children:"AttachmentQueue"})," that extends ",(0,s.jsx)(n.code,{children:"AbstractAttachmentQueue"})," from ",(0,s.jsx)(n.code,{children:"@journeyapps/powersync-attachments"}),"."]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"import { AbstractAttachmentQueue } from '@journeyapps/powersync-attachments';\n\nexport class AttachmentQueue extends AbstractAttachmentQueue {\n  \n}\n"})}),"\n",(0,s.jsxs)(n.ol,{start:"2",children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Implement ",(0,s.jsx)(n.code,{children:"attachmentIds"}),", an ",(0,s.jsx)(n.code,{children:"AsyncIterator"})," method to return an array of ",(0,s.jsx)(n.code,{children:"string"})," values of IDs that relate to attachments in your app. We recommend using ",(0,s.jsx)(n.code,{children:"PowerSync"}),"'s ",(0,s.jsx)(n.code,{children:"watch"})," query to return the all IDs of attachments in your app."]}),"\n",(0,s.jsxs)(n.p,{children:["In this example, we query all photos that have been captured as part of an inspection and map these to an array of ",(0,s.jsx)(n.code,{children:"string"})," values."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"import { AbstractAttachmentQueue } from '@journeyapps/powersync-attachments';\n\nexport class AttachmentQueue extends AbstractAttachmentQueue {\n  async *attachmentIds() {\n    for await (const result of this.powersync.watch(\n      `SELECT photo_id as id FROM checklists WHERE photo_id IS NOT NULL`,\n      []\n    )) {\n      yield result.rows?._array.map((r) => r.id) ?? [];\n    }\n  }\n}\n"})}),"\n",(0,s.jsxs)(n.ol,{start:"3",children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Implement ",(0,s.jsx)(n.code,{children:"newAttachmentRecord"})," to return an object that represents the attachment record in your app."]}),"\n",(0,s.jsxs)(n.p,{children:["In this example we always work with ",(0,s.jsx)(n.code,{children:"JPEG"})," images, but you can use any media type that is supported by your app and storage solution. Note: we are set the state to ",(0,s.jsx)(n.code,{children:"QUEUED_UPLOAD"})," when creating a new photo record which assumes that the photo data is already on the device."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"import { AbstractAttachmentQueue } from '@journeyapps/powersync-attachments';\n\nexport class AttachmentQueue extends AbstractAttachmentQueue {\n  // ...\n   async newAttachmentRecord(record) {\n      const photoId = record?.id ?? uuid();\n      const filename = record?.filename ?? `${photoId}.jpg`;\n      return {\n         id: photoId,\n         filename,\n         media_type: 'image/jpeg',\n         state: AttachmentState.QUEUED_UPLOAD,\n         ...record\n      };\n   }\n}\n"})}),"\n",(0,s.jsxs)(n.ol,{start:"4",children:["\n",(0,s.jsxs)(n.li,{children:["Add an ",(0,s.jsx)(n.code,{children:"AttachmentTable"})," to your app's PowerSync Schema:"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"import { AttachmentTable } from '@journeyapps/powersync-attachments';\n\nconst AppSchema = new Schema([\n   // ... other tables\n   new AttachmentTable()\n]);\n"})}),"\n",(0,s.jsxs)(n.p,{children:["In addition to ",(0,s.jsx)(n.code,{children:"Table"})," options, the ",(0,s.jsx)(n.code,{children:"AttachmentTable"})," can optionally be configured with the following options:"]}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Option"}),(0,s.jsx)(n.th,{children:"Description"}),(0,s.jsx)(n.th,{children:"Default"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"name"})}),(0,s.jsx)(n.td,{children:"The name of the table"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"attachments"})})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"additionalColumns"})}),(0,s.jsxs)(n.td,{children:["An array of addition ",(0,s.jsx)(n.code,{children:"Column"})," objects added to the default columns in the table"]}),(0,s.jsx)(n.td,{children:"See below for default columns"})]})]})]}),"\n",(0,s.jsxs)(n.p,{children:["The default columns in ",(0,s.jsx)(n.code,{children:"AttachmentTable"}),":"]}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Column Name"}),(0,s.jsx)(n.th,{children:"Type"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"id"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"TEXT"})}),(0,s.jsx)(n.td,{children:"The ID of the attachment record"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"filename"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"TEXT"})}),(0,s.jsx)(n.td,{children:"The filename of the attachment"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"media_type"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"TEXT"})}),(0,s.jsx)(n.td,{children:"The media type of the attachment"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"state"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"INTEGER"})}),(0,s.jsxs)(n.td,{children:["The state of the attachment, one of ",(0,s.jsx)(n.code,{children:"AttachmentState"})," enum values"]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"timestamp"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"INTEGER"})}),(0,s.jsx)(n.td,{children:"The timestamp of last update to the attachment record"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"size"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"INTEGER"})}),(0,s.jsx)(n.td,{children:"The size of the attachment in bytes"})]})]})]}),"\n",(0,s.jsxs)(n.ol,{start:"5",children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["To instantiate an ",(0,s.jsx)(n.code,{children:"AttachmentQueue"}),", one needs to provide an instance of ",(0,s.jsx)(n.code,{children:"AbstractPowerSyncDatabase"})," from PowerSync and an instance of ",(0,s.jsx)(n.code,{children:"StorageAdapter"}),".\nSee the ",(0,s.jsx)(n.code,{children:"StorageAdapter"})," interface definition ",(0,s.jsx)(n.a,{href:"./src/StorageAdapter.ts",children:"here"}),"."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Instantiate a new ",(0,s.jsx)(n.code,{children:"AttachmentQueue"})," and call ",(0,s.jsx)(n.code,{children:"init()"})," to start syncing attachments. Our example, uses a ",(0,s.jsx)(n.code,{children:"StorageAdapter"})," that integrates with Supabase Storage."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"this.storage = this.supabaseConnector.storage;\nthis.powersync = factory.getInstance();\n\nthis.attachmentQueue = new AttachmentQueue({\n   powersync: this.powersync,\n   storage: this.storage\n});\n\n// Initialize and connect PowerSync ...\n// Then initialize the attachment queue\nawait this.attachmentQueue.init();\n"})}),"\n",(0,s.jsxs)(n.ol,{start:"7",children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Finally, to create an attachment and add it to the queue, call ",(0,s.jsx)(n.code,{children:"saveToQueue()"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["In our example we added a ",(0,s.jsx)(n.code,{children:"savePhoto()"})," method to our ",(0,s.jsx)(n.code,{children:"AttachmentQueue"})," class, that does this:"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"\nexport class AttachmentQueue extends AbstractAttachmentQueue {\n  // ...\n  async savePhoto(base64Data) {\n    const photoAttachment = await this.newAttachmentRecord();\n    photoAttachment.local_uri = this.getLocalUri(photoAttachment.filename);\n    await this.storage.writeFile(photoAttachment.local_uri, base64Data, { encoding: 'base64' });\n\n    return this.saveToQueue(photoAttachment);\n  }\n\n}\n"})}),"\n",(0,s.jsx)(n.h1,{id:"implementation-details",children:"Implementation details"}),"\n",(0,s.jsx)(n.h2,{id:"attachment-state",children:"Attachment State"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"AttachmentQueue"})," class manages attachments in your app by tracking their state."]}),"\n",(0,s.jsx)(n.p,{children:"The state of an attachment can be one of the following:"}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"State"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"QUEUED_SYNC"})}),(0,s.jsx)(n.td,{children:"Check if the attachment needs to be uploaded or downloaded"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"QUEUED_UPLOAD"})}),(0,s.jsx)(n.td,{children:"The attachment has been queued for upload to the cloud storage"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"QUEUED_DOWNLOAD"})}),(0,s.jsx)(n.td,{children:"The attachment has been queued for download from the cloud storage"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"SYNCED"})}),(0,s.jsx)(n.td,{children:"The attachment has been synced"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"ARCHIVED"})}),(0,s.jsx)(n.td,{children:"The attachment has been orphaned, i.e. the associated record has been deleted"})]})]})]}),"\n",(0,s.jsx)(n.h2,{id:"initial-sync",children:"Initial sync"}),"\n",(0,s.jsxs)(n.p,{children:["Upon initializing the ",(0,s.jsx)(n.code,{children:"AttachmentQueue"}),", an initial sync of attachments will take place if the ",(0,s.jsx)(n.code,{children:"performInitialSync"})," is set to true.\nAny ",(0,s.jsx)(n.code,{children:"AttachmentRecord"})," with ",(0,s.jsx)(n.code,{children:"id"})," in first set of IDs retrieved from the watch query will be marked as ",(0,s.jsx)(n.code,{children:"QUEUED_SYNC"}),", and these records will be rechecked to see if they need to be uploaded or downloaded."]}),"\n",(0,s.jsx)(n.h2,{id:"syncing-attachments",children:"Syncing attachments"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"AttachmentQueue"})," sets up two watch queries on the ",(0,s.jsx)(n.code,{children:"attachments"})," table, one for records in ",(0,s.jsx)(n.code,{children:"QUEUED_UPLOAD"})," state and one for ",(0,s.jsx)(n.code,{children:"QUEUED_DOWNLOAD"})," state."]}),"\n",(0,s.jsxs)(n.p,{children:["In addition to watching for changes, the ",(0,s.jsx)(n.code,{children:"AttachmentQueue"})," also triggers a sync every few seconds. This will retry any failed uploads/downloads, in particular after the app was offline."]}),"\n",(0,s.jsxs)(n.p,{children:["By default, this is every 30 seconds, but can be configured by setting ",(0,s.jsx)(n.code,{children:"syncInterval"})," in the ",(0,s.jsx)(n.code,{children:"AttachmentQueue"})," constructor options, or disabled by setting the interval to ",(0,s.jsx)(n.code,{children:"0"}),"."]}),"\n",(0,s.jsx)(n.h3,{id:"uploading",children:"Uploading"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["An ",(0,s.jsx)(n.code,{children:"AttachmentRecord"})," is created or updated with a state of ",(0,s.jsx)(n.code,{children:"QUEUED_UPLOAD"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["The ",(0,s.jsx)(n.code,{children:"AttachmentQueue"})," picks this up and upon successful upload to Supabase, sets the state to ",(0,s.jsx)(n.code,{children:"SYNCED"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["If the upload is not successful, the record remains in ",(0,s.jsx)(n.code,{children:"QUEUED_UPLOAD"})," state and uploading will be retried when syncing triggers again."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"downloading",children:"Downloading"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["An ",(0,s.jsx)(n.code,{children:"AttachmentRecord"})," is created or updated with ",(0,s.jsx)(n.code,{children:"QUEUED_DOWNLOAD"})," state."]}),"\n",(0,s.jsxs)(n.li,{children:["The watch query adds the ",(0,s.jsx)(n.code,{children:"id"})," into a queue of IDs to download and triggers the download process"]}),"\n",(0,s.jsx)(n.li,{children:"This checks whether the photo is already on the device and if so, skips downloading."}),"\n",(0,s.jsx)(n.li,{children:"If the photo is not on the device, it is downloaded from cloud storage."}),"\n",(0,s.jsx)(n.li,{children:"Writes file to the user's local storage."}),"\n",(0,s.jsxs)(n.li,{children:["If this is successful, update the ",(0,s.jsx)(n.code,{children:"AttachmentRecord"}),"  state to ",(0,s.jsx)(n.code,{children:"SYNCED"}),"."]}),"\n",(0,s.jsx)(n.li,{children:"If any of these fail, the download is retried in the next sync trigger."}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"deleting-attachments",children:"Deleting attachments"}),"\n",(0,s.jsx)(n.p,{children:"When an attachment is deleted by a user action or cache expiration:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Related ",(0,s.jsx)(n.code,{children:"AttachmentRecord"})," is removed from attachments table."]}),"\n",(0,s.jsx)(n.li,{children:"Local file (if exists) is deleted."}),"\n",(0,s.jsx)(n.li,{children:"File on cloud storage is deleted."}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"expire-cache",children:"Expire Cache"}),"\n",(0,s.jsx)(n.p,{children:"When PowerSync removes a record, as a result of coming back online or conflict resolution for instance:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Any associated ",(0,s.jsx)(n.code,{children:"AttachmentRecord"})," is orphaned."]}),"\n",(0,s.jsxs)(n.li,{children:["On the next sync trigger, the ",(0,s.jsx)(n.code,{children:"AttachmentQueue"})," sets all records that are orphaned to ",(0,s.jsx)(n.code,{children:"ARCHIVED"})," state."]}),"\n",(0,s.jsxs)(n.li,{children:["By default, the ",(0,s.jsx)(n.code,{children:"AttachmentQueue"})," only keeps the last ",(0,s.jsx)(n.code,{children:"100"})," attachment records and then expires the rest."]}),"\n",(0,s.jsxs)(n.li,{children:["This can be configured by setting ",(0,s.jsx)(n.code,{children:"cacheLimit"})," in the ",(0,s.jsx)(n.code,{children:"AttachmentQueue"})," constructor options."]}),"\n"]})]})}function o(e={}){const{wrapper:n}={...(0,c.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},1151:(e,n,t)=>{t.d(n,{Z:()=>i,a:()=>d});var s=t(7294);const c={},a=s.createContext(c);function d(e){const n=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(c):e.components||c:d(e.components),s.createElement(a.Provider,{value:n},e.children)}}}]);